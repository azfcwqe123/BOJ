<img width="1205" height="913" alt="image" src="https://github.com/user-attachments/assets/5ac667d0-36cc-4810-92a7-6181a4a43200" />

문제: https://www.acmicpc.net/problem/1377

---

### Hint

1. 시간 제한 2초, 첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다.

- O(N^2)으로 풀면 시간 초과가 확정이기 때문에 다른 방법을 유도해야함.

&nbsp;

2. 코드 해석

```cpp
bool changed = false;
for (int i=1; i<=N+1; i++) {
    changed = false; // 버블 정렬이 발생했는지?
    for (int j=1; j<=N-i; j++) {
        if (A[j] > A[j+1]) { // 버블 정렬 발생
            changed = true; // 체크
            swap(A[j], A[j+1]);
        }
    }
    if (changed == false) { // 버블 정렬이 발생하지 않음 = 정렬 완료
        cout << i << '\n';
        break;
    }
}
```
- 버블 정렬이 발생하지 않았을때, 총 몇번의 버블 정렬이 일어났는지 횟수를 구하고, 버블 정렬이 일어나지 않은 마지막 구간(체크 용도)까지 계산해서 답을 유도해내면 됨.

&nbsp;

3. 버블정렬 원리
- 버블 정렬이 일어날때, 요소는 뒤쪽으로는 얼마든지 이동할 수 있지만 앞쪽으로는 한칸씩 밖에 밀려나지 않는다는 원리를 이용해야한다. **앞쪽으로 가장 많이 이동한 요소가 이동하는 동안, 나머지 요소들은 자연스럽게 제자리를 찾아간다.** 그렇기에 버블 정렬의 최대 이동 횟수를 찾기 위해서는 앞쪽에서부터 탐색해주면 된다.

---

버블 정렬 원리 이용

```java
import java.util.*;
import java.io.*;

class Main {

    static class Point implements Comparable<Point> {
        int num, idx;

        Point(int num, int idx) {
            this.num = num;
            this.idx = idx;
        }

        @Override
        public int compareTo(Point ob) { // 숫자 기준 정렬
            return this.num - ob.num;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    public static void main(String[] args) throws IOException {
        
        int n = Integer.parseInt(br.readLine());
        int ans = 0;

        Point[] arr = new Point[n];

        for(int i=0; i<n; i++) {
            arr[i] = new Point(Integer.parseInt(br.readLine()), i);
        }

        Arrays.sort(arr);

        for(int i=0; i<n; i++) {
            // 앞쪽에서 부터 탐색. '정렬 전 인덱스 - 정렬 후 인덱스'의 가장 큰 값이 정답
            ans = Math.max(ans, arr[i].idx - i);
        }
        
        System.out.println(ans + 1);
    }    
}


```