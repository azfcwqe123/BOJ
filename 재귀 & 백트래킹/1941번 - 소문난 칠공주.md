<img width="1206" height="812" alt="image" src="https://github.com/user-attachments/assets/77b16aee-1075-4127-9d07-2d255debec65" />

문제: https://www.acmicpc.net/problem/1941

---

### Hint

1. 이름이 이름인 만큼, 7명의 여학생들로 구성되어야 한다.

- 조합으로 7명을 추려낸다.
&nbsp;

2. 강한 결속력을 위해, 7명의 자리는 서로 가로나 세로로 반드시 인접해 있어야 한다.
- 문제에는 총 25명의 여학생들로 이루어져있다고 했다. 7명의 여학생이라면 어떻게 뽑든 가로 세로로 연결돼있기에, 7명을 뽑기만 하면 된다. 이때 가로 세로로 연결돼있는지의 여부는 BFS 알고리즘을 이용해 체크하도록 한다.

3. 화합과 번영을 위해, 반드시 ‘이다솜파’의 학생들로만 구성될 필요는 없다.
그러나 생존을 위해, ‘이다솜파’가 반드시 우위를 점해야 한다. 따라서 7명의 학생 중 ‘이다솜파’의 학생이 적어도 4명 이상은 반드시 포함되어 있어야 한다.
- 조합을 사용해서 7명을 추려낼때, 이다솜파가 4명이 뽑힌 경우가 생겨버리면 이 경우의 수는 건너뛰도록 조건을 넣도록 한다.

![2BNxXRlDtqEFnavScz2QO3_250815_183227_1](https://github.com/user-attachments/assets/87c62010-208c-4846-852e-1e47e382a54f)

![2BNxXRlDtqEFnavScz2QO3_250815_183227_2](https://github.com/user-attachments/assets/1a0849bd-d6a7-42ae-8965-be0526b2291c)


---

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static char[][] map = new char[5][5];
    static boolean[] selected = new boolean[25];
    static boolean[][] visited;
    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    static int ans = 0;
    public static void main(String[] args) throws IOException {
        
        for(int i=0; i<5; i++) {
            String str = br.readLine();
            for(int j=0; j<5; j++) {
                map[i][j] = str.charAt(j);
            }
        }

        combi(0, 0, 0); // 7명의 학생을 뽑고, 문제의 조건에 부합하는지 체크한다.

        System.out.println(ans);
    }    

    static void combi(int st, int depth, int yCnt) {

        // '임도연파' 학생이 4명 이상이 되면 '이다솜파'는 우위를 점하지 못함
        if(yCnt == 4) return;

        // 7명의 학생을 채웠다면
        if(depth == 7) {
            // 바로 직전 학생 좌표를 보내서 체크한다.
            BFS((st - 1) / 5, (st - 1) % 5);
            return;
        }

        for(int i=st; i<25; i++) {
            selected[i] = true;

            if(map[i / 5][i % 5] == 'Y') combi(i+1, depth+1, yCnt+1); // 임도연파
            else combi(i+1, depth+1, yCnt); // 이다솜파

            selected[i] = false;
        }

    }

    static void BFS(int x, int y) {
        Queue<int[]> Q = new LinkedList<>();
        Q.offer(new int[] {x, y});

        visited = new boolean[5][5];
        visited[x][y] = true;

        int cnt = 1;

        while(!Q.isEmpty()) {

            int[] cur = Q.poll();

            for(int d=0; d<4; d++) {
                int nx = cur[0] + dx[d];
                int ny = cur[1] + dy[d];
                int idx = nx * 5 + ny;

                // 배열 범위X or 이미 방문 or 선택되지 않은 학생이라면 PASS
                if(!rangeCheck(nx, ny) || visited[nx][ny] || !selected[idx]) continue;

                Q.offer(new int[] {nx, ny});
                visited[nx][ny] = true;
                cnt++;
            }
        } 
        
        // 가로, 세로로 모두 연결돼있었다면 칠공주 결성
        if(cnt == 7) ans++;
    }   

    static boolean rangeCheck(int nx, int ny) {
        return nx >= 0 && ny >= 0 && nx < 5 && ny < 5;
    }

}


```

---

### 테스트 케이스

1
```
YYYYY
SYSYS
YYYYY
YSYYS
YYYYY
```

```
2
```