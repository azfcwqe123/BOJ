<img width="1082" height="555" alt="image" src="https://github.com/user-attachments/assets/4b2f8afa-2ce9-4974-9a67-a7152e5f62e7" />

문제: https://www.acmicpc.net/problem/2251

---

### Hint

1. 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오.

- BFS을 이용하여 모든 경우의 수를 탐색한다.

```java
// 물통 -> 물통 경우의 수
static int[] from = {0, 0, 1, 1, 2, 2};
static int[] to = {1, 2, 0, 2, 0, 1};
```


---

BFS

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int A, B, C;
    static boolean[][] visited;
    static boolean[] answer;
    // 물통 -> 물통 경우의 수
    static int[] from = {0, 0, 1, 1, 2, 2};
    static int[] to = {1, 2, 0, 2, 0, 1};
    static int[] size;
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());

        A = Integer.parseInt(st.nextToken());
        B = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());
        size = new int[] {A, B, C}; // 각 물통별 사이즈

        visited = new boolean[A+1][B+1]; // A, B 물통의 방문 여부만 알아도 C는 자동 유추
        answer = new boolean[C+1]; // A가 0일때 C의 양

        BFS();

        for(int i=0; i<=C; i++) {
            if(answer[i]) System.out.print(i + " ");
        }
    }    

    static void BFS() {
        Queue<int[]> Q = new LinkedList<>();
        Q.offer(new int[] {0, 0, C}); // 시작
        visited[0][0] = true; 
        
        while(!Q.isEmpty()) {
            int[] now = Q.poll();

            // A가 0일때 C의 양 체크
            if(now[0] == 0) answer[now[2]] = true;

            // 물통을 옮기는 경우의 수
            for(int d=0; d<6; d++) {
                int[] next = {now[0], now[1], now[2]};

                next[to[d]] += next[from[d]]; // 물 전체 옮기기
                next[from[d]] = 0; // 물 옮긴 통은 비게 됨

                if(next[to[d]] > size[to[d]]) { // 물 받은 통이, 자신의 사이즈보다 크다면
                    next[from[d]] = next[to[d]] - size[to[d]]; // 물 옮긴 통에 넘친 양 넘기기
                    next[to[d]] = size[to[d]]; // 물 받은 통은 꽉 찬 상태 유지
                }

                if(!visited[next[0]][next[1]]) { // 없었던 경우의 수라면
                    visited[next[0]][next[1]] = true; // 방문 체크
                    Q.offer(next); 
                }

            }
        }

    }
}


```

---

### 테스트 케이스

1
```
8 9 10
```

```
1 2 8 9 10
```
