

문제: https://www.acmicpc.net/problem/1197

---

### Hint

1. 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리
- 최소 신장 트리는 사이클이 포함되면 가중치의 합이 최소가 될 수 없음.
- N개의 노드가 있다면 최소 신장 트리를 구선하는 간선의 수는 N-1개임.

참고: https://loosie.tistory.com/159

---

크루스칼 알고리즘

```java
import java.util.*;
import java.io.*;

class Main {

    static class Node implements Comparable<Node> {
        int from, to, w;

        public Node(int from, int to, int w) {
            this.from = from;
            this.to = to;
            this.w = w;
        }

        @Override
        public int compareTo(Node ob) {
            return this.w - ob.w;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int v, e, ans = 0;
    static PriorityQueue<Node> pQ = new PriorityQueue<>();
    static int[] parent;
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        v = Integer.parseInt(st.nextToken()); // 노드 수
        e = Integer.parseInt(st.nextToken()); // 간선 수

        parent = new int[v + 1];
        for(int i=1; i<=v; i++) parent[i] = i;

        for(int i=0; i<e; i++) {
            st = new StringTokenizer(br.readLine());
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());

            pQ.offer(new Node(from, to, weight));
        }

        kruskal(); // 크루스칼 알고리즘

        System.out.println(ans);
    }    

    static void kruskal() {

        int len = pQ.size();

        // for(int i=0; i<pQ.size(); i++) 하면 틀림. pQ.size()가 매번 새로 갱신돼버림
        for(int i=0; i<len; i++) { 
            Node cur = pQ.poll();

            // 같은 부모가 아니라면 연결해도 사이클이 안 생김.
            if(find(cur.from) != find(cur.to)) {
                union(cur.from, cur.to); // 간선 잇기
                ans += cur.w;
            }
        }

    }

    // 유니온 파인드
    static void union(int a, int b) {
        a = find(a);
        b = find(b);

        if(a != b) parent[a] = b;
    }

    static int find(int a) {
        if(parent[a] == a) return a;
        else return parent[a] = find(parent[a]);
    }
}


```

---

프림 알고리즘

```java
import java.util.*;
import java.io.*;

class Main {

    static class Node implements Comparable<Node> {
        int v, w;

        public Node(int v, int w) {
            this.v = v;
            this.w = w;
        }

        @Override
        public int compareTo(Node ob) {
            return this.w - ob.w;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int v, e, ans = 0;
    static ArrayList<Node>[] graph;
    static boolean[] visisted;
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        v = Integer.parseInt(st.nextToken()); // 노드 수
        e = Integer.parseInt(st.nextToken()); // 간선 수

        graph = new ArrayList[v+1];
        visisted = new boolean[v+1];

        for(int i=1; i<=v; i++) graph[i] = new ArrayList<>();

        for(int i=0; i<e; i++) {
            st = new StringTokenizer(br.readLine());
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());

            graph[from].add(new Node(to, weight));
            graph[to].add(new Node(from, weight));
        }

        prim(1); // 프림 알로리즘

        System.out.println(ans);
    }    

    static void prim(int start) {
        PriorityQueue<Node> pQ = new PriorityQueue<>();
        pQ.offer(new Node(1, 0)); // 시작

        while(!pQ.isEmpty()) {
            Node cur = pQ.poll();

            if(visisted[cur.v]) continue; // 이미 MST에 포함된 정점이면 건너뜀
            visisted[cur.v] = true; // MST에 현재 정점을 포함시킴.

            // 우선순위 큐에 의해서 가중치가 가장 낮은 정점과 자동 연결 됨
            ans += cur.w; 

            // 현재 노드와 연결된 모든 간선 확인
            for(Node next : graph[cur.v]) {
                if(!visisted[next.v]) { // 방문되지 않은 노드가 있다면
                    pQ.offer(next); // 큐에 후보 간선으로 추가
                }
            }
        }
    }

}
```

---

### 테스트 케이스

1
```
3 3
1 2 1
2 3 2
1 3 3
```

```
3
```
