![image](https://github.com/user-attachments/assets/00310608-280b-46cd-b08a-5480f1d3734a)

문제 출처: https://www.acmicpc.net/problem/11404

---

### 그림 설명

![image](https://github.com/user-attachments/assets/949fd266-3f48-4491-aa06-c5d3e07b38f0)

- 같은 경로로 중복해서 나온 경우, 가중치가 더 작은 것으로 선정한다.
  
---

### Hint

1. 모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램

- 모든 정점에서 모든 정점으로의 최단 경로를 구하는 것 -> 플로이드 워셜 알고리즘

- 하나의 정점에서 다른 모든 정점으로의 최단 경로 -> 다익스트라 알고리즘

---

플로이드 워셜
 
```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int n, m;
    static int[][] distance;

    // 최대 가중치 = 100000, 최대 간선 수 = 100(도시 수) - 1
    // 최악의 경우, 도시 A -> B의 비용의 최솟값은 100000 * 99이므로, +1을 해줘서 INF로 설정
    static int INF = (100 - 1) * 100000 + 1;
    public static void main(String[] args) throws IOException {
        
        n = Integer.parseInt(br.readLine());
        m = Integer.parseInt(br.readLine());

        distance = new int[n+1][n+1];
        
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=n; j++) {
                if(i==j) distance[i][j] = 0; // 현재 도시에서 현재 도시로는 비용이 들지 않음.
                else distance[i][j] = INF; // 모든 도시간의 거리를 INF로 설정. 최소 비용을 구하기 위한 것
            }
        }

        // A -> B로 가는 버스의 수
        for(int i=0; i<m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());

            // 같은 경로라도, 비용이 더 낮은 경로를 우선
            distance[a][b] = Math.min(c, distance[a][b]);
        }


        // 플로이드 워셜 
        // i -> k로 가고, k -> j로 가는 것과 i -> j로 가는 것은 동일한 경로
        for(int k=1; k<=n; k++) {
            for(int i=1; i<=n; i++) {
                for(int j=1; j<=n; j++) {
                    // i -> k, k -> j의 경로와 i -> j의 경로중 비용이 더 작은 것 갱신
                    if(distance[i][j] > distance[i][k] + distance[k][j]) {
                        distance[i][j] = distance[i][k] + distance[k][j];
                    }
                }
            }
        }

        // 정답 출력
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=n; j++) {
                if(distance[i][j] == INF) sb.append("0 ");
                else sb.append(distance[i][j] + " ");
            }
            sb.append("\n");
        }

        System.out.println(sb);

    }    
}
```

---

### ✅ 다익스트라 vs 플로이드-워셜 정리표

| 항목          | **다익스트라 알고리즘**                   | **플로이드-워셜 알고리즘**            |
| ----------- | -------------------------------- | --------------------------- |
| **목적**      | 한 정점 → 모든 정점 최단 거리               | 모든 정점 ↔ 모든 정점 최단 거리         |
| **시간 복잡도**  | `O((V + E) log V)` (우선순위 큐 사용 시) | `O(V³)` (정점이 작을 때만 효율적)     |
| **가중치 조건**  | **음수 간선 ❌ 불가**                   | **음수 간선 ✅ 가능** (음수 사이클은 ❌)  |
| **그래프 크기**  | 정점 수 많아도 OK (`V ≤ 10,000` 적합)    | 정점 수 작아야 효율적 (`V ≤ 100` 적합) |
| **알고리즘 유형** | 그리디 + 우선순위 큐                     | DP (동적 계획법) 기반              |
| **출발 지점 수** | 한 지점 기준으로 여러 정점 거리 계산            | 모든 지점 기준으로 모든 거리 계산         |
| **대표 사용 예** | 네비게이션, 한 도시에서 다른 도시까지 이동         | 항공사 요금표, 모든 도시 간 비용 계산      |

by ChatGPT