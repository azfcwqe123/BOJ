![image](https://github.com/user-attachments/assets/00310608-280b-46cd-b08a-5480f1d3734a)

문제 출처: https://www.acmicpc.net/problem/11404

---

### 그림 설명

![image](https://github.com/user-attachments/assets/949fd266-3f48-4491-aa06-c5d3e07b38f0)

- 같은 경로로 중복해서 나온 경우, 가중치가 더 작은 것으로 선정한다.
  
---

### Hint

1. 모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램

- 모든 정점에서 모든 정점으로의 최단 경로를 구하는 것 -> 플로이드 와샬 알고리즘

- 하나의 정점에서 다른 모든 정점으로의 최단 경로 -> 다익스트라 알고리즘

---

플로이드 와샬
 
```cpp
#include <bits/stdc++.h>
using namespace std;

// 최대 가중치 = 100000, 최대 간선 수 = 100(도시 수) - 1
// 최악의 경우, 도시 A -> B의 비용의 최솟값은 100000 * 99이므로, +1을 해줘서 INF로 설정

const int INF = 100000 * (100 - 1) + 1;

int n, m, st, ed, w;

// 행: A, 열: B
// A(시작 도시) -> B(도착 도시)
int dist[101][101]; 

int main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    
    cin >> n >> m;
    
    fill(dist[0], dist[101], INF); // 모든 도시간의 거리를 INF로 설정. 최소 비용을 구하기 위한 것
    
    for(int i=1; i<=n; i++) dist[i][i] = 0; // 현재 도시에서 현재 도시로는 비용이 들지 않음.
    
    while(m--) { // A -> B로 가는 버스의 수
        cin >> st >> ed >> w;
        
        dist[st][ed] = min(dist[st][ed], w); // 같은 경로라도, 비용이 더 낮은 경로를 우선
    }
    
    // 플로이드 와샬 
    // i -> k로 가고, k -> j로 가는 것과 i -> j로 가는 것은 동일한 경로
    for(int k=1; k<=n; k++) {
        for(int i=1; i<=n; i++) {
            for(int j=1; j<=n; j++) {
                // i -> k, k -> j의 경로와 i -> j의 경로중 비용이 더 작은 것 갱신
                dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);
            }
        }
    }
    
    // 정답 출력
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++) {
            if(dist[i][j] == INF) cout << "0 ";
            else cout << dist[i][j] << " ";
        } 
        cout << '\n';
    }
    
}
```

---

### ✅ 다익스트라 vs 플로이드-와샬 정리표

| 항목          | **다익스트라 알고리즘**                   | **플로이드-와샬 알고리즘**            |
| ----------- | -------------------------------- | --------------------------- |
| **목적**      | 한 정점 → 모든 정점 최단 거리               | 모든 정점 ↔ 모든 정점 최단 거리         |
| **시간 복잡도**  | `O((V + E) log V)` (우선순위 큐 사용 시) | `O(V³)` (정점이 작을 때만 효율적)     |
| **가중치 조건**  | **음수 간선 ❌ 불가**                   | **음수 간선 ✅ 가능** (음수 사이클은 ❌)  |
| **그래프 크기**  | 정점 수 많아도 OK (`V ≤ 10,000` 적합)    | 정점 수 작아야 효율적 (`V ≤ 100` 적합) |
| **알고리즘 유형** | 그리디 + 우선순위 큐                     | DP (동적 계획법) 기반              |
| **출발 지점 수** | 한 지점 기준으로 여러 정점 거리 계산            | 모든 지점 기준으로 모든 거리 계산         |
| **대표 사용 예** | 네비게이션, 한 도시에서 다른 도시까지 이동         | 항공사 요금표, 모든 도시 간 비용 계산      |

by ChatGPT