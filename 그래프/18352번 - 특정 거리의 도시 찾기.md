<img width="1074" height="920" alt="image" src="https://github.com/user-attachments/assets/460d9bf7-09c8-44ea-92ad-86739b7ce19f" />

문제: https://www.acmicpc.net/problem/18352

---

### Hint

1. 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력

- 가중치가 없는 단순 최단 거리 경로 구하는 문제는 방문 여부 표시를 한 뒤, 한 번 방문했던곳은 방문하지 않으면서 이동 거리를 누적 시킨다. 하지만 가중치가 있는 경우에는 **다익스트라 알고리즘**을 사용한다.

---

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static int n, m, k, x;
    static ArrayList<Integer>[] graph;
    static int[] visited;
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(st.nextToken());
        x = Integer.parseInt(st.nextToken());
        
        graph = new ArrayList[n + 1];
        visited = new int[n + 1];
        for(int i=1; i<=n; i++) graph[i] = new ArrayList<>();

        // 방문처리 -1로 해줘야함. 0으로 하면 방문여부를 구분하지 못하는 실수 가능.
        for(int i=1; i<=n; i++) visited[i] = -1; 

        for(int i=0; i<m; i++) {
            st = new StringTokenizer(br.readLine());    
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());

            graph[s].add(e);
        }

        BFS(x);

        // 정답을 담을 배열
        ArrayList<Integer> ans = new ArrayList<>();

        // X로부터 최단 거리가 정확히 K인 모든 도시들 탐색
        for(int i=1; i<=n; i++) {
            if(visited[i] == k) ans.add(i);
        } 

        // 없다면 -1 출력하고 종료
        if(ans.size() == 0) {
            System.out.println(-1);
            System.exit(0);
        } else { // 있다면 오름차순 정렬 후, 출력
            Collections.sort(ans);
            for(int x : ans) System.out.println(x);
        }

    }    

    static void BFS(int node) {
        Queue<Integer> Q = new LinkedList<>();
        Q.offer(x);
        visited[x]++; // 시작지점 방문체크. 
        // 방문체크 안하면 시작지점을 다시 방문하는 오류 발생

        while(!Q.isEmpty()) {
            int cur = Q.poll(); // 현재의 정점에서

            for(int to : graph[cur]) { // 다른 정점으로
                if(visited[to] == -1) { // 한 번도 방문하지 않은 곳만 이동 (최단거리 성질 이용)
                    visited[to] = visited[cur] + 1; // 누적 거리
                    Q.offer(to); 
                }
            }
        }

    }
}


```

---

### 테스트 케이스

1
```
4 4 2 1
1 2
1 3
2 3
2 4
```
4
```

```

&nbsp;

2
```
4 3 2 1
1 2
1 3
1 4
```

```
-1
```

&nbsp;

3
```
4 4 1 1
1 2
1 3
2 3
2 4
```

```
2
3
```