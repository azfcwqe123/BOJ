<img width="1178" height="911" alt="image" src="https://github.com/user-attachments/assets/3ab0bd72-c0f5-49b7-a0cd-5d74b4438206" />

문제: https://www.acmicpc.net/problem/1219

---

### Hint

1. 오민식이 버는 돈보다 쓰는 돈이 많다면, 도착 도시에 도착할 때 가지고 있는 돈의 액수가 음수가 될 수도 있다. 또, 같은 도시를 여러 번 방문할 수 있으며, 그 도시를 방문할 때마다 돈을 벌게 된다.

- 돈을 가장 많이 벌 수 있는 경로로 벨만 포드 알고리즘을 변형해서 사용한다.

&nbsp;

2. 만약 오민식이 도착 도시에 도착하는 것이 불가능할 때는 "gg"를 출력한다. 그리고, 오민식이 도착 도시에 도착했을 때 돈을 무한히 많이 가지고 있을 수 있다면 "Gee"를 출력한다.

- 돈을 무한히 가질 수 있다는 것은, 양수 사이클이 돌아서 돈복사를 하고 도착 도시를 갈 수 있다는 뜻임. 양수 사이클을 찾아내는게 핵심인 문제이다.
  - 벨만 포드 알고리즘은 n개의 점점 개수에서 n-1번까지는 정상적인 경로 전파
  - 이 문제에서 n번째부터 사이클 도는 것은 양수 사이클 유무 판정 구간이 됨. 보통 벨만포드 알고리즘은 n번째부터 음수 사이클을 판정함.


![hYBJtbKSwEwldPF4xS7ARE_250827_232014_1](https://github.com/user-attachments/assets/41beb186-888b-4bf9-b444-8d3a940680d3)

![hYBJtbKSwEwldPF4xS7ARE_250827_232014_2](https://github.com/user-attachments/assets/ade3f93b-ef32-4738-bfb0-06d19d10b80e)

![hYBJtbKSwEwldPF4xS7ARE_250827_232014_3](https://github.com/user-attachments/assets/f513622a-dedd-4eae-8ac7-2cd8c2f7d500)

---

```java
import java.util.*;
import java.io.*;

class Main {

    static class Node {
        int from, to, price;
        
        Node(int from, int to, int price) {
            this.from = from;
            this.to = to;
            this.price = price;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int n, m, sCity, eCity;
    static long[] distance, cityMoney;
    static Node[] node;

    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        sCity = Integer.parseInt(st.nextToken());
        eCity = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        
        node = new Node[m];
        distance = new long[n];
        cityMoney = new long[n];
        Arrays.fill(distance, Long.MIN_VALUE);

        for(int i=0; i<m; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int price = Integer.parseInt(st.nextToken()); // 교통비
            node[i] = new Node(s, e, price);
        }

        st = new StringTokenizer(br.readLine());
        // 해당 도시에 벌 수 있는 돈
        for(int i=0; i<n; i++) cityMoney[i] = Long.parseLong(st.nextToken());

        distance[sCity] = cityMoney[sCity]; // 출발 지점

        // 벨만 포드
        for(int i=0; i<=n+100; i++) { // 양수 사이클이 전파되도록 충분히 큰 수로 반복
            for(int j=0; j<m; j++) {
                Node cur = node[j];

                // 방문하지 않은 노드면 Skip
                if(distance[cur.from] == Long.MIN_VALUE) continue;

                // 양수 사이클이 돌게됨
                else if(distance[cur.from] == Long.MAX_VALUE) {
                    distance[cur.to] = Long.MAX_VALUE;
                }

                // 더 많은 돈을 벌 수 있는 경로로 갱신
                else if(distance[cur.to] < distance[cur.from] + cityMoney[cur.to] - cur.price) {
                    distance[cur.to] = distance[cur.from] + cityMoney[cur.to] - cur.price;

                    // n-1번 이후에도 갱신이 일어나면, 양수 사이클의 영향을 받는 노드임
                    if(i >= n-1) distance[cur.to] = Long.MAX_VALUE;
                }
            }
        }

        // n-1번까지는 정상적인 최단경로 전파
        // n번째부터 사이클 유무 판정 구간

        if(distance[eCity] == Long.MIN_VALUE) System.out.println("gg");
        else if(distance[eCity] == Long.MAX_VALUE) System.out.println("Gee");
        else System.out.println(distance[eCity]);

    }    
}


```

---

### 테스트 케이스

1
```
5 0 4 7
0 1 13
1 2 17
2 4 20
0 3 22
1 3 4747
2 0 10
3 4 10
0 0 0 0 0
```

```
-32
```

&nbsp;

2
```
5 0 4 5
0 1 10
1 2 10
2 3 10
3 1 10
2 4 10
0 10 10 110 10
```

```
Gee
```


3
```
3 0 2 3
0 1 10
1 0 10
2 1 10
1000 1000 47000
```

```
gg
```