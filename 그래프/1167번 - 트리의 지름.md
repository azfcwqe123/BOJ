<img width="976" height="738" alt="image" src="https://github.com/user-attachments/assets/18ef386f-f74f-45f4-8bf3-b38335afe318" />

문제: https://www.acmicpc.net/problem/1167

---

1. 그래프에서 가장 거리가 먼 요소의 두 정점을 찾으려면?
- 임의의 노드를 잡는다.
- 임의의 노드에서 가장 먼 거리의 노드를 탐색한다.
- 방금 탐색한 노드에서 가장 먼 거리의 노드를 탐색한다.

![8PN9k1tE7UqNqufkSbLJIi_250813_105021](https://github.com/user-attachments/assets/59d34d6d-f0f2-44e1-a3e3-6af70850e53c)

---

DFS 탐색

```java
import java.util.*;
import java.io.*;

class Main {

    static class Edge {
        int e;
        int w;

        Edge(int e, int w) {
            this.e = e;
            this.w = w;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int v, maxDistance = -1;
    static ArrayList<Edge>[] graph;
    static boolean[] visited;
    static int farthestEdge;
    public static void main(String[] args) throws IOException {
        
        v = Integer.parseInt(br.readLine());

        graph = new ArrayList[v + 1];
        visited = new boolean[v + 1];

        for(int i=1; i<=v; i++) graph[i] = new ArrayList<>();

        for(int i=1; i<=v; i++) {
            st = new StringTokenizer(br.readLine());

            int node = Integer.parseInt(st.nextToken());

            while(true) {
                int to = Integer.parseInt(st.nextToken());
                if(to == -1) break;
                int w = Integer.parseInt(st.nextToken());

                graph[node].add(new Edge(to, w));
            }

        }
        
        DFS(1, 0); // 현재 노드에서 가장 거리가 먼 높은 노드 탐색
        maxDistance = 0; // 가장 먼 거리 초기화
        visited = new boolean[v + 1]; // 방문 초기화

        DFS(farthestEdge, 0); // 가장 멀리 있던 정점에서 가장 먼 정점까지 거리 탐색
        System.out.println(maxDistance);
    }    

    static void DFS(int v, int dis) {

        visited[v] = true; 

        if(dis > maxDistance) { // 가장 먼 거리보다 멀다면
            maxDistance = dis; // 가장 먼 거리 갱신
            farthestEdge = v; // 가장 먼 노드 갱신
        }

        for(Edge x : graph[v]) {
            if(!visited[x.e]) {
                DFS(x.e, dis + x.w);
            } 
        }

    }

}
```
