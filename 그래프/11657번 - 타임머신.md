<img width="1180" height="641" alt="image" src="https://github.com/user-attachments/assets/a3173a4b-2609-45c6-86c8-a206d55128f6" />

문제: https://www.acmicpc.net/problem/11657

---

### Hint


1. 만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다.

- 음수 사이클이 있으면 시간이 무한히 전으로 돌아간다. 음수 사이클을 체크할 수 있는 벨만 포드 알고리즘을 사용하자.

2. 코드 해석
```java
// 도시의 개수보다 1개 적은 수만큼 반복
for(int i=1; i<n; i++) {
    for(int j=0; j<m; j++) { // 모든 노드 탐색
        Node cur = node[j];

        // 최단 경로 갱신
        if(distance[cur.from] != Integer.MAX_VALUE && distance[cur.to] > distance[cur.from] + cur.time) {
            distance[cur.to] = distance[cur.from] + cur.time;
        }
    }
}
```
여기서 도시의 개수 -1 적은 수만큼 반복하는 이유는?

- 1회만 돌려도 모든 최단거리가 계산되는 경우도 있음.

- 하지만 도시 개수 -1 만큼 반복하는 이유는, 최악의 경우 마지막 노드까지 가려면 V-1번 완화가 필요하기 때문.

- 벨만 포드의 표준 방식은 인접리스트처럼 구조적인 순서와 상관없음. 그렇기에 매 회차마다 모든 간선을 전부 확인함.

참고 : https://great-park.tistory.com/134

---

```java
import java.util.*;
import java.io.*;

class Main {

    static class Node {
        int from, to, time;

        Node(int from, int to, int time) {
            this.from = from;
            this.to = to;
            this.time = time;
        }
    }

    static long[] distance;
    static Node[] node;

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int n, m;
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        node = new Node[m+1];
        distance = new long[n+1];
        Arrays.fill(distance, Integer.MAX_VALUE);

        for(int i=0; i<m; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int t = Integer.parseInt(st.nextToken());

            node[i] = new Node(s, e, t);
        }

        // 시작점
        distance[1] = 0;

        // 도시의 개수보다 1개 적은 수만큼 반복
        for(int i=1; i<n; i++) {
            for(int j=0; j<m; j++) { // 모든 노드 탐색
                Node cur = node[j];

                // 최단 경로 갱신
                if(distance[cur.from] != Integer.MAX_VALUE && distance[cur.to] > distance[cur.from] + cur.time) {
                    distance[cur.to] = distance[cur.from] + cur.time;
                }
            }
        }

        // 음수 사이클 여부
        boolean mCycle = false;

        // 음수 사이클 체크 (다시 돌렸을때, 최단 경로에 변화가 있으면 음수사이클 존재한다는 뜻)
        for(int i=0; i<m; i++) {
            Node cur = node[i];

            if(distance[cur.from] != Integer.MAX_VALUE && distance[cur.to] > distance[cur.from] + cur.time) {
                mCycle = true;
                break;
            }
        }

        // 음수 사이클이 없다면
        if(!mCycle) {
            for(int i=2; i<=n; i++) {
                if(distance[i] == Integer.MAX_VALUE) sb.append("-1");
                else sb.append(distance[i]);
                sb.append("\n");
            }
        } else sb.append("-1");

        System.out.println(sb);

    }    
}


```

---

### 테스트 케이스

1
```
3 4
1 2 4
1 3 3
2 3 -1
3 1 -2
```

```
4
3
```

&nbsp;

2
```
3 4
1 2 4
1 3 3
2 3 -4
3 1 -2
```

```
-1
```

&nbsp;

3
```
3 2
1 2 4
1 2 3
```

```
3
-1
```