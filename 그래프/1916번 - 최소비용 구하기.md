<img width="1827" height="976" alt="image" src="https://github.com/user-attachments/assets/33b759d4-4f42-478e-8f49-aaa457ad02a9" />

문제: https://www.acmicpc.net/problem/1753

---

### Hint

1. 다익스트라의 핵심 원리

- 정점이 꺼내지는 순간(poll) → 그 정점까지의 최단 거리가 확정된다고 가정
- 음수 간선이 있으면 안 됨. 나중에 더 짧은 경로가 발견될 수 있기 때문

---

```java
import java.util.*;
import java.io.*;

class Main {

    static class Node implements Comparable<Node> {
        int v, cost;

        Node(int v, int cost) {
            this.v = v;
            this.cost = cost;
        }

        @Override
        public int compareTo(Node ob) {
            return this.cost - ob.cost;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int n, m;
    static ArrayList<Node>[] graph;
    static int[] dist;
    static boolean[] visited;
    static int INF = (1000 - 1) * 100000 + 1;
    public static void main(String[] args) throws IOException {
        
        n = Integer.parseInt(br.readLine());
        m = Integer.parseInt(br.readLine());

        graph = new ArrayList[n+1];
        dist = new int[n+1];
        visited = new boolean[n+1];

        for(int i=1; i<=n; i++) graph[i] = new ArrayList<>();
        Arrays.fill(dist, INF);

        for(int i=0; i<m; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());

            graph[s].add(new Node(e, cost));
        }

        st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int end = Integer.parseInt(st.nextToken());

        dijkst(start);

        System.out.println(dist[end]);
        
    }   
    
    // 다익스트라
    static void dijkst(int start) {
        PriorityQueue<Node> pQ = new PriorityQueue<>();
        pQ.offer(new Node(start, 0));
        dist[start] = 0;

        while(!pQ.isEmpty()) {
            Node cur = pQ.poll();

            if(visited[cur.v]) continue;
            visited[cur.v] = true;

            for(Node next : graph[cur.v]) {
                if(dist[next.v] > dist[cur.v] + next.cost) {
                    dist[next.v] = dist[cur.v] + next.cost;
                    pQ.offer(new Node(next.v, dist[next.v]));
                }
            }
        }
    }

}
```

---

### 테스트 케이스

1
```
5
8
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
1 5
```

```
4
```
