<img width="1817" height="1233" alt="image" src="https://github.com/user-attachments/assets/fb55c7de-511c-4744-878a-60d4f85ef4a9" />


문제: https://www.acmicpc.net/problem/1948

---

### Hint

![bm7sG69oJDMhj2f5Ilj9oI-1_250825_190939](https://github.com/user-attachments/assets/cff42106-3951-4396-ba9a-94804224de40)

1.  이들이 만나는 시간은 출발 도시로부터 출발한 후 최소 몇 시간 후에 만날 수 있는가?

- 최소 몇 시간 후라면서 최대 거리를 구하는 이유는, 사람들이 반드시 최단 경로만 타는 보장이 없기 때문

2. 둘째 줄에는 1분도 쉬지 않고 달려야 하는 도로의 수가 몇 개인지 출력하여라.
- 최대 거리를 구한 뒤, 역으로 거슬러서 이 경로를 타고 가는 횟수를 구하면 된다. 

---

```java
import java.util.*;
import java.io.*;

class Main {

    static class Node {
        int v, w; // 도착 정점, 가중치

        Node(int v, int w) {
            this.v = v;
            this.w = w;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int n, m, start, end, ans = 0;
    static ArrayList<Node>[] adj, reverseAdj; // 순방향, 역방향 인접리스트
    static int[] indegree, distance; // 진입 차수 배열, 최대 경로 누적 거리 배열 
    static boolean[] visited; // 역추적 시 중복 방문 방지
    
    public static void main(String[] args) throws IOException {
        
        n = Integer.parseInt(br.readLine());
        m = Integer.parseInt(br.readLine());

        adj = new ArrayList[n+1];
        reverseAdj = new ArrayList[n+1];
        indegree = new int[n+1];
        distance = new int[n+1];
        visited = new boolean[n+1];

        for(int i=1; i<=n; i++) {
            adj[i] = new ArrayList<>();
            reverseAdj[i] = new ArrayList<>();
        }

        for(int i=0; i<m; i++) {
            st = new StringTokenizer(br.readLine());

            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());

            adj[s].add(new Node(e, w));
            reverseAdj[e].add(new Node(s, w));
            indegree[e]++;
        }

        st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        end = Integer.parseInt(st.nextToken());

        Topological_sort(); // 위상 정렬

        solution(); // 도로의 수 구하기

        System.out.println(distance[end]); // 최장 경로 길이
        System.out.println(ans); // 임계 경로에 포함된 도로 개수
    }    

    static void Topological_sort() {
        Queue<Integer> Q = new LinkedList<>();

        for(int i=1; i<=n; i++) {
            if(indegree[i] == 0) Q.offer(i);
        }

        while(!Q.isEmpty()) {
            int cur = Q.poll();

            for(Node next : adj[cur]) {
                distance[next.v] = Math.max(distance[next.v], distance[cur] + next.w); // 최대 경로 구하기

                if(--indegree[next.v] == 0) Q.offer(next.v);
            }
        }
    }

    static void solution() {
        Queue<Integer> Q = new LinkedList<>();
        Q.offer(end);

        while(!Q.isEmpty()) {
            int cur = Q.poll();

            for(Node next : reverseAdj[cur]) {
                
                if(distance[next.v] + next.w == distance[cur]) { // 역방향으로 갈때, 최대 경로의 루트와 같다면
                    ans++; // 임계 경로 도로 하나 발견
                    if(!visited[next.v]) { // 한 번도 방문하지 않은 경로만 간다.
                        visited[next.v] = true; // 방문 체크
                        Q.offer(next.v);
                    }
                }
            }
        }

    }

}


```

---

### 테스트 케이스

1
```
7
9
1 2 4
1 3 2
1 4 3
2 6 3
2 7 5
3 5 1
4 6 4
5 6 2
6 7 5
1 7
```

```
12
5
```