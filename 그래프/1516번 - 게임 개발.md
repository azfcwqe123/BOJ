<img width="1765" height="1094" alt="image" src="https://github.com/user-attachments/assets/3e00bb55-85ca-45b6-97b1-2fa0f24ce888" />


문제: https://www.acmicpc.net/problem/1516

---

### Hint

반례 조심!

![TCjSXAXMv1W09miADPSjvq_250825_171908_1](https://github.com/user-attachments/assets/8415d89f-9e42-4496-b66c-63d113e5dc1d)

---

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static Scanner sc = new Scanner(System.in);
    static StringBuilder sb = new StringBuilder();
    static int n;
    static ArrayList<Integer>[] adj; // 인접리스트
    static int[] indegree; // 정점의 위상 순서
    static int[] time; // 자신의 건물을 짓는데 걸리는 시간
    static int[] ans; // i번째 건물을 짓는데 걸리는 총 시간
    public static void main(String[] args) throws IOException {
        
        n = sc.nextInt();

        adj = new ArrayList[n+1];
        indegree = new int[n+1];
        time = new int[n+1];
        ans = new int[n+1];

        for(int i=1; i<=n; i++) adj[i] = new ArrayList<>();

        for(int i=1; i<=n; i++) {
            int t = sc.nextInt();
            time[i] = t;

            while(true) {
                int order = sc.nextInt(); // i번째 건물을 지으려면 order번째 건물이 선행으로 먼저 지어져야함.
                if(order == -1) break;

                adj[order].add(i);
                indegree[i]++;
            }
        }

        Topological_sort(); // 위상 정렬

        for(int i=1; i<=n; i++) {
            sb.append(ans[i] + "\n");
        }

        System.out.println(sb);
    }    

    static void Topological_sort() {

        Queue<Integer> Q = new LinkedList<>();
        
        for(int i=1; i<=n; i++) {
            if(indegree[i] == 0) Q.offer(i); // 위상 순서가 0인 정점은 큐에 넣는다.
        }

        while(!Q.isEmpty()) {
            int cur = Q.poll();
            ans[cur] += time[cur]; // 현재 자신의 건물을 짓는데 걸리는 시간

            for(int next : adj[cur]) { // 자신의 건물을 먼저 짓고, 다음에 지을 수 있는 건물들(next)
                ans[next] = Math.max(ans[next], ans[cur]); // 다음 건물은 시간이 가장 많이 걸렸던 루트로 (루트가 여러개 존재할 수 있기 때문)
                if(--indegree[next] == 0) Q.offer(next); 
            }
        }

    }

}
```

---

### 테스트 케이스

1
```
5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1
```

```
10
20
14
18
17
```

&nbsp;

2 (반례)

https://www.acmicpc.net/board/view/158707

```
6
10 -1
1 1 -1
1 2 -1
1 3 -1
8 1 -1
4 4 5 -1
```

```
10
11
12
13
18
22
```