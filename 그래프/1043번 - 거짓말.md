<img width="1087" height="740" alt="image" src="https://github.com/user-attachments/assets/674ed283-cad9-4944-a565-7289428fc797" />

문제: https://www.acmicpc.net/problem/1043

---

### Hint

![ofYjhxiWD5ZWHh5FVMRGC2_250818_231925_1](https://github.com/user-attachments/assets/e75cc650-d6a3-407c-849e-32162a540c06)

![ofYjhxiWD5ZWHh5FVMRGC2_250818_231925_2](https://github.com/user-attachments/assets/0caf5c2e-63cd-4e2c-821c-a47b52116a45)

---

유니온 파인드

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int n, m, k, ans = 0;
    static int[] unf;
    static ArrayList<Integer>[] party;
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken()); // 사람의 수
        m = Integer.parseInt(st.nextToken()); // 파티의 수

        st = new StringTokenizer(br.readLine());
        k = Integer.parseInt(st.nextToken()); // 진실을 아는 사람의 수

        if(k == 0) { // 진실을 아는 사람이 없다면, 모든 파티에 거짓말을 해도됨
            System.out.println(m);
            System.exit(0);
        }

        int[] trueP = new int[k]; // 진실을 아는 사람의 수
        for(int i=0; i<k; i++) trueP[i] = Integer.parseInt(st.nextToken());
        
        party = new ArrayList[m]; // 각 파티의 사람 명단

        for(int i=0; i<m; i++) {
            party[i] = new ArrayList<>(); // 파티 생성

            st = new StringTokenizer(br.readLine());
            int size = Integer.parseInt(st.nextToken()); // 파티 사이즈

            while(size-- > 0) { // 사람 추가
                party[i].add(Integer.parseInt(st.nextToken()));
            }
        }

        // 같은 집합에 속해있는지 확인하기 위함
        unf = new int[n+1];
        for(int i=1; i<=n; i++) unf[i] = i;

        // 같은 파티 인원들끼리 같은 집합에 속하게 함
        for(int i=0; i<m; i++) {
            int first = party[i].get(0);
            for(int j=1; j<party[i].size(); j++) {
                union(first, party[i].get(j));
            }
        }

        for(int i=0; i<m; i++) {
            boolean flag = true; // 지민이가 파티에서 거짓말을 할 수 있을지 여부
            int cur = party[i].get(0); // 파티 대표가
            for(int j=0; j<trueP.length; j++) {
                if(find(cur) == find(trueP[j])) { // 진실을 아는 사람과 같이 있다면
                    flag = false; // 거짓말 불가능
                    break; 
                }
            }

            // 진실을 아는 사람과 아무 접점도 없다면 거짓말 가능
            if(flag) ans++;
        }

        System.out.println(ans);

    }    

    static void union(int p, int c) {
        p = find(p);
        c = find(c);

        if(p != c) unf[c] = p;
    }

    static int find(int v) {
        if(unf[v] == v) return v;
        else return unf[v] = find(unf[v]);
    }

}

```

---

### 테스트 케이스

1
```
4 3
0
2 1 2
1 3
3 2 3 4
```

```
3
```

&nbsp;

2
```
4 1
1 1
4 1 2 3 4
```

```
0
```

&nbsp;

3
```
4 1
0
4 1 2 3 4
```

```
1
```

&nbsp;

4
```
4 5
1 1
1 1
1 2
1 3
1 4
2 4 1
```

```
2
```

&nbsp;

5
```
10 9
4 1 2 3 4
2 1 5
2 2 6
1 7
1 8
2 7 8
1 9
1 10
2 3 10
1 4
```

```
4
```

&nbsp;

6
```
8 5
3 1 2 7
2 3 4
1 5
2 5 6
2 6 8
1 8
```

```
5
```

&nbsp;

7
```
3 4
1 3
1 1
1 2
2 1 2
3 1 2 3
```

```
0
```