<img width="1860" height="1120" alt="image" src="https://github.com/user-attachments/assets/9e8ebdca-91b5-44f5-ad66-a4975714f45b" />

문제: https://www.acmicpc.net/problem/1744

---

### Hint

1. 어떤 수열이 {0, 1, 2, 4, 3, 5}일 때, 그냥 이 수열의 합을 구하면 0+1+2+4+3+5 = 15이다. 하지만, 2와 3을 묶고, 4와 5를 묶게 되면, 0+1+(2*3)+(4*5) = 27이 되어 최대가 된다.

- 우선순위큐를 생각할 수 있다. 숫자가 양수일때는 내림차순의 우선순위큐에 넣고, 음수일때는 오름차순의 우선순위큐에 넣는다. 그리고 각각의 우선순위 큐에서 2개씩 꺼냈을때, 이 두 개의 값을 곱한 값이 더 큰지, 더한 값이 더 큰지 판별한 후 정답에 값을 누적시킨다.

- 양수를 담는 우선순위큐에 {4, 3, 1, 1}의 값이 있다고 가정해보자. 이때 두 개의 값을 꺼내면 4, 3이 나오는데, 4 * 3이 4 + 3보다 크다. 하지만 1 1을 꺼내면, 1 + 1이 1 * 1보다 크다. 그러므로 아래와 같은 알고리즘을 세운다.

```java
    static void calculate(PriorityQueue<Integer> Q) {

        while(Q.size() > 1) {
            a = Q.poll();
            b = Q.poll();

            ans += Math.max(a * b, a + b);
        }
    }
```

&nbsp;

2. 음수도, 양수도 아닌 0은 어떤 큐에 넣을까?
- 만약 0이 양수를 담는 우선순위큐에 있다고 가정하면, 위의 calculate() 함수를 실행할때, a * b의 값을 0으로 만들어버린다. 합이 최대가 되게 하는 프로그램을 만드는 데에 전혀 도움을 주지 않는다.

- 만약 0이 음수를 담는 우선순위큐에 있다고 가정하면, a * b을 실행했을때 음수의 값을 없애주는 역할을 한다. 합이 최대가 되게 하게끔 도와주는 역할을 한다. 그러므로 0은 음수를 담는 우선순위큐에 넣는다.

---

그리디 알고리즘

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static int ans = 0, a, b;
    public static void main(String[] args) throws IOException {
        
        int n = Integer.parseInt(br.readLine());

        PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.reverseOrder());
        PriorityQueue<Integer> mQ = new PriorityQueue<>();

        while(n-- > 0) {
            int k = Integer.parseInt(br.readLine());

            if(k > 0) pQ.offer(k);
            else mQ.offer(k);
        }

        calculate(pQ); // 2개씩 꺼내서 1개가 남을때까지 계산
        calculate(mQ); // 2개씩 꺼내서 1개가 남을때까지 계산

        if(!pQ.isEmpty() && !mQ.isEmpty()) { // 만약 둘 다 한 개씩 남아있다면 
            a = pQ.poll();
            b = mQ.poll();

            ans += Math.max(a * b, a + b);
        }
        else if(!pQ.isEmpty()) ans += pQ.poll(); // pQ에만 한 개가 남아있다면
        else if(!mQ.isEmpty()) ans += mQ.poll(); // mQ에만 한 개가 남아있다면

        System.out.println(ans);
    }    

    static void calculate(PriorityQueue<Integer> Q) {

        while(Q.size() > 1) {
            a = Q.poll();
            b = Q.poll();

            ans += Math.max(a * b, a + b);
        }
    }
}

```