<img width="1798" height="913" alt="image" src="https://github.com/user-attachments/assets/5ce0b0bc-2a70-47a0-ae93-2d8aac377c71" />

문제: https://www.acmicpc.net/problem/1931

---

### Hint

1. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자.

- 끝나는 시간을 기준으로 오름차순 정렬을 한다. 만약 끝나는 시간이 같을 경우엔 시작 시간을 기준으로 오름차순 정렬을 한다.
- 만약, (2, 2), (1, 2)의 회의가 있다고 가정해보자. 위의 설명처럼 제대로 정렬을 했다면, (1, 2) 회의 다음 (2, 2) 회의가 진행된다. 하지만 (2, 2), (1, 2) 순서라면 (2, 2) 회의가 끝난 뒤에는 (1, 2) 회의를 진행할 수 없게 된다. 이는 회의의 최대 개수를 구하기에 위반되는 조건임.

---

그리디 알고리즘

```java
import java.util.*;
import java.io.*;

class Main {

    static class Point implements Comparable<Point> {
        int s, e;

        Point(int s, int e) {
            this.s = s;
            this.e = e;
        }

        @Override
        public int compareTo(Point ob) {
            if(this.e == ob.e) return this.s - ob.s; // 종료 시간이 같다면 시작 시간으로 정렬
            return this.e - ob.e; // 종료 시간으로 정렬
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws IOException {
        
        int n = Integer.parseInt(br.readLine());

        ArrayList<Point> list = new ArrayList<>();
        
        for(int i=0; i<n; i++) {
            st = new StringTokenizer(br.readLine());
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());

            list.add(new Point(s, e));
        }

        Collections.sort(list);

        int ans = 0, prev_time = 0; // 회의 개수, 이전 시간

        for(int i=0; i<n; i++) {
            if(prev_time <= list.get(i).s) { // 회의 시작 시간이, 이전 시간(이전 회의 종료 시간)보다 같거나 크다면 
                prev_time = list.get(i).e; // 회의 시작 -> 이전 시간을 회의 종료 시간으로 갱신
                ans++; // 회의 개수 + 1
            }
        }

        System.out.println(ans);

    }    
}


```