<img width="1084" height="856" alt="image" src="https://github.com/user-attachments/assets/6c15f23a-4ae4-42df-8225-e25992565163" />

문제 출처: https://www.acmicpc.net/problem/17298

---

### Hint

1. 시간 제한 1초, 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.
- O(N^2) 방법의 브루트포스 탐색으로 풀면 시간 초과함.
- 다른 알고리즘을 이용해서 시간복잡도를 줄여야한다.

2. 예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다.
- 오른쪽부터 탐색해나가면서, 오른쪽의 수보다 작으면 오큰수를 갱신하는 규칙을 보아 스택 사용을 추론해볼 수 있다.

<img width="448" height="453" alt="image" src="https://github.com/user-attachments/assets/51883cc6-0f0d-4b26-a9b9-f4bcafbac3af" />

---

스택

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    public static void main(String[] args) throws IOException {
        
        int n = Integer.parseInt(br.readLine());

        int[] arr = new int[n]; // 수열 배열
        int[] ans = new int[n]; // 정답 배열

        st = new StringTokenizer(br.readLine());
        for(int i=0; i<n; i++) arr[i] = Integer.parseInt(st.nextToken());    
        
        Stack<Integer> stack = new Stack<>();

        for(int i=0; i<n; i++) { // A1 ~ An
            
            // 현재 수열 값(arr[i], 오큰수)이 top보다 크다면 갱신
            while(!stack.isEmpty() && arr[stack.peek()] < arr[i]) {
                ans[stack.pop()] = arr[i]; // 정답 배열에 오큰수 갱신
            }
            
            // 현재 수열 값의 오큰수도 찾아줘야함.
            stack.push(i);
        }

        // 오큰수가 없는 수들은 마지막에 처리
        while(!stack.isEmpty()) {
            ans[stack.pop()] = -1;
        }

        for(int x : ans) sb.append(x + " ");
        System.out.println(sb);
    }    
}


```

