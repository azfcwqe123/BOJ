<img width="1119" height="646" alt="image" src="https://github.com/user-attachments/assets/464b2601-5359-495c-9d60-334ecbc36680" />

문제: https://www.acmicpc.net/problem/1655

---

### Hint

![Q5zzrGDsalprncFy0RIYVm_250812_154530_1](https://github.com/user-attachments/assets/bbe27bb9-50ef-43cc-a9cd-4b21c9248c99)

![Q5zzrGDsalprncFy0RIYVm_250812_154530_2](https://github.com/user-attachments/assets/ff65affe-a029-407c-adb5-b518a6352d85)

최대힙과 최소힙의 숫자 규칙을 찾을 수 있다.

&nbsp;

Swap을 해야하는 상황이 왔을 경우

![Q5zzrGDsalprncFy0RIYVm_250812_154530_3](https://github.com/user-attachments/assets/ed80863d-5af6-42d8-98df-b094a532dff1)

---

우선순위 큐, O(NlogN)

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    public static void main(String[] args) throws IOException {
        
        int n = Integer.parseInt(br.readLine());

        PriorityQueue<Integer> minHeap = new PriorityQueue<>((o1, o2) -> o1 - o2); 
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);

        while(n-- > 0) {
            int k = Integer.parseInt(br.readLine());

            // 최대힙, 최소힙 사이즈 같으면 최대힙 우선
            if(maxHeap.size() == minHeap.size()) maxHeap.offer(k); // O(logN)
            else minHeap.offer(k); // O(logN)

            // 스왑해야하는 상황이 온다면, O(1)
            if(!minHeap.isEmpty() && !maxHeap.isEmpty()) {
                if(maxHeap.peek() >= minHeap.peek()) {
                    int tmp = maxHeap.poll();
                    maxHeap.offer(minHeap.poll());
                    minHeap.offer(tmp);
                }
            }

            // 필요할때 스왑을 해줘야 최대힙과 최소힙에 있는 숫자의 정렬이 서로 규칙에 맞게끔 설정된다.

            // 최대힙에 있는 첫번째 요소가 중간값, 중간에 있는 두 수중 작은값 모두 만족함.
            sb.append(maxHeap.peek() + "\n");
        }

        System.out.println(sb);
    }    
}

 
```

---

틀린 코드 (시간 초과)

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    public static void main(String[] args) throws IOException {
        
        int n = Integer.parseInt(br.readLine());

        PriorityQueue<Integer> pQ = new PriorityQueue<>(); 
        Stack<Integer> stack = new Stack<>();
        int cnt = 0;

        while(n-- > 0) { // O(N)
            int k = Integer.parseInt(br.readLine());
            cnt++;

            pQ.offer(k);

            if(cnt % 2 != 0) { // 홀수
                int tmp = cnt / 2;
                
                for(int i=0; i<tmp; i++) stack.push(pQ.poll()); // O(N/2 * logN)
                sb.append(pQ.peek() + "\n");
                while(!stack.isEmpty()) pQ.offer(stack.pop()); // O(N/2 * logN)
            }

            else { // 짝수
                int tmp = cnt / 2;
                for(int i=0; i<tmp; i++) stack.push(pQ.poll());
                sb.append(Math.min(stack.peek(), pQ.peek()) + "\n");
                while(!stack.isEmpty()) pQ.offer(stack.pop());
            }
            
        }

        System.out.println(sb);
        
    }    
}

```

테스트 케이스 결과대로 나오긴 하지만, 최종 시간 복잡도는 O(N^2 * logN)으로 0.1초의 시간제한으로 통과할 수 없다.