<img width="1076" height="864" alt="image" src="https://github.com/user-attachments/assets/6334e968-d3a7-4459-8ff5-be0bd562e724" />

문제: https://www.acmicpc.net/problem/3190

---

### Hint

1. **배열에 뱀의 경로를 일일이 체크한다면?**
- 모든 한칸한칸 모두 옮겨야 하므로 로직이 매우 복잡해짐. 쓰면 안 됨.
- 다른 방법으로, 머리와 꼬리만 이용해서 이동을 시키면 된다. -> 덱 사용

&nbsp;

2. 다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데, 정수 X와 문자 C로 이루어져 있으며 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다.
- 뱀의 방향 변환 정보를 확실하게 이해하고 사용해야함.
- 뱀이 이동하고 난 뒤, 방향을 전환시킨다는 뜻 포함

---

시뮬레이션

```java
import java.util.*;
import java.io.*;

class Main {

    static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    
    static int[][] map;
    static int n, k, x, y, t, time, dir = 1;
    static char r;
    static int[] dx = {-1, 0, 1, 0}; // 북동남서
    static int[] dy = {0, 1, 0, -1};
    static Deque<Point> dq = new LinkedList<>();
    static char[] rotate = new char[10001];
    public static void main(String[] args) throws IOException {
        
        n = Integer.parseInt(br.readLine());
        map = new int[n][n];

        k = Integer.parseInt(br.readLine());

        while(k-- > 0) {
            st = new StringTokenizer(br.readLine());
            x = Integer.parseInt(st.nextToken());
            y = Integer.parseInt(st.nextToken());
            
            map[x - 1][y - 1] = 1; // 사과 위치
        } 

        k = Integer.parseInt(br.readLine());
        
        while(k-- > 0) {
            st = new StringTokenizer(br.readLine());
            t = Integer.parseInt(st.nextToken());
            r = st.nextToken().charAt(0);

            rotate[t] = r; // 회전 예약 시간
        }
        
        start(); // 게임 시작

        System.out.println(time + 1); // 벽에 부딪히는 시간까지 포함하여 계산
    }

    // 이동 시, 뒤에 있는 꼬리를 떼다가  앞으로
    // 사과를 먹을 시, 앞칸에 채우기

    // 북쪽: 0, 동쪽: 1, 남쪽: 2, 서쪽: 3
    static void start() {
        dq.offer(new Point(0, 0)); // 뱀의 첫 시작 -> 맨 위 좌측, 방향은 오른쪽

        while(true) {            
            Point cur = dq.peekFirst(); // 현재 뱀의 머리

            // 방향대로 움직인다면?
            int nx = cur.x + dx[dir];
            int ny = cur.y + dy[dir];

            if(!rangeCheck(nx, ny)) return; // 벽에 부딪혔을 경우 -> 게임 끝

            for(Point p : dq) { // 자신과 부딪히는 경우 -> 게임 끝
                if(p.x == nx && p.y == ny) return;
            }

            if(map[nx][ny] == 1) { // 사과 발견
                map[nx][ny] = 0;
                dq.offerFirst(new Point(nx, ny)); // 그대로 길이를 늘려줌
            } else { // 그냥 이동 시
                dq.offerFirst(new Point(nx, ny)); // 한 칸 이동
                dq.pollLast(); // 꼬리 삭제(한 칸 이동하는 것과 똑같은 원리)
            }

            time++; // 움직이고 난 뒤, 시간이 흘러감
            
            // 방향에 따른 변환
            if(rotate[time] == 'D') dir = (dir + 1) % 4;
            else if(rotate[time] == 'L') dir = (dir + 3) % 4;
        }

    }

    static boolean rangeCheck(int nx, int ny) {
        return nx >= 0 && ny >= 0 && nx < n && ny < n;
    }
}


```