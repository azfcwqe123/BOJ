<img width="1134" height="933" alt="image" src="https://github.com/user-attachments/assets/897f469a-d05e-4ba0-8f85-f561e4a79bf1" />

문제: https://www.acmicpc.net/problem/12100

참고: https://hidelookit.tistory.com/183

---

### Hint

![cGF85BNYYbolqmAb0o8pKZ_250814_163630_1](https://github.com/user-attachments/assets/66ecca26-0a64-450d-902c-720568a6aeae)

![cGF85BNYYbolqmAb0o8pKZ_250814_163630_2](https://github.com/user-attachments/assets/86ff4c55-ddbb-4b18-9cc7-dc6902cf9edf)

---

시뮬레이션, 백트래킹

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    
    static int n, max = -1;
    static int[][] map;
    static int[][] tmp;
    static boolean[][] visited;

    // up, down, right, left
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, 1, -1};
    static int[] direct = new int[5];
    public static void main(String[] args) throws IOException {
        
        n = Integer.parseInt(br.readLine());

        map = new int[n][n];

        for(int i=0; i<n; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<n; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        dfs(5, 0); // 백트래킹

        System.out.println(max);

    }    

    static void dfs(int end, int cnt) {

        // 방향이 모두 정해지면 2048의 최댓값 탐색 시작
        if(end == cnt) confirm();
        
        else {
            for(int i=0; i<4; i++) {
                direct[cnt] = i;
                dfs(end, cnt + 1);
            }
        }

    }

    static void confirm() {
        
        // 임시 배열 (하나의 경우의 수)
        tmp = new int[n][n];

        for(int i=0; i<n; i++) tmp[i] = map[i].clone();

        for(int dir : direct) {
            visited = new boolean[n][n]; // 숫자가 합쳐졌던 곳 체크

            switch(dir) {
                case 0 : // up
                    for(int i=0; i<n; i++) {
                        for(int j=0; j<n; j++) {
                            move(i, j, dir);
                        }
                    }
                    break;

                case 1 : // down
                    for(int i=n-1; i>=0; i--) {
                        for(int j=0; j<n; j++) {
                            move(i, j, dir);
                        }
                    }
                    break;

                case 2 : // right
                    for(int i=0; i<n; i++) {
                        for(int j=n-1; j>=0; j--) {
                            move(i, j, dir);
                        }
                    }
                    break;

                case 3 : // left
                    for(int i=0; i<n; i++) {
                        for(int j=0; j<n; j++) {
                            move(i, j, dir);
                        }
                    }
                    break;
            }

            for(int i=0; i<n; i++) {
                for(int j=0; j<n; j++) {
                    max = Math.max(max, tmp[i][j]);
                }
            }

        }
    }

    static void move(int x, int y, int dir) {

        // 0이면 이동 X
        if(tmp[x][y] == 0) return;

        while(true) {
            int nx = x + dx[dir];
            int ny = y + dy[dir];

            // 배열 범위 X or 숫자가 합쳐졌던 곳이라면 PASS
            if(!rangeCheck(nx, ny) || visited[nx][ny]) return;

            // 이동할 위치와 숫자가 같다면 합친다.
            if(tmp[nx][ny] == tmp[x][y]) {
                visited[nx][ny] = true; // 숫자 합친 곳 체크
                tmp[nx][ny] *= 2; // ex) 4 4 -> 4 8 (오른쪽 이동)
                tmp[x][y] = 0; // ex) 4 8 -> 0 8 (오른쪽 이동)
                return;
            } 
            
            // 이동할 위치와 숫자가 다르다면 움직이지 않는다.
            else if(tmp[nx][ny] != 0) { 
                return;
            }

            // 이동할 위치의 숫자가 0이라면, 현재 위치에서 이동만 한다.
            tmp[nx][ny] = tmp[x][y];
            tmp[x][y] = 0;
            x = nx;
            y = ny;
        }

    }

    static boolean rangeCheck(int nx, int ny) {
        return nx >= 0 && ny >= 0 && nx < n && ny < n;
    }
    
}


```