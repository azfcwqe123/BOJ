<img width="966" height="917" alt="image" src="https://github.com/user-attachments/assets/2d9451ba-1f11-4bda-99d0-dd45a6ddc4f0" />

문제: https://www.acmicpc.net/problem/16236

---

### Hint
1.

- 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.
- 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.
- 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.
  
→ 조건에 따른 정렬로 상어의 이동 위치를 우선순위큐에 넣을때, 우선순위큐의 첫번째 요소는 위의 3가지 요건을 가장 충족을 잘 시키는 최단 경로의 위치가 된다.

→ 일단 우선순위 큐에 넣고, 정렬을 시킨 다음 꺼내서 물고기를 먹을 수 있는지 확인하는게 편함. 탐색하는 와중에 확인하려면 코드가 의도대로 작동이 안 될 수 있음.

ex)

```java
            // 물고기 탐색 시작
            while(!pQ.isEmpty()) {
                cur = pQ.poll(); // 상어의 현재 위치

                // 현재 위치에서 사방면 탐색
                for(int d=0; d<4; d++) {
                    int nx = cur.x + dx[d];
                    int ny = cur.y + dy[d];

                    // 범위X or 이미 방문 or 자신보다 큰 물고기라면 PASS
                    if(!rangeCheck(nx, ny) || visited[nx][ny] || map[nx][ny] > size) continue;


                    // 현재 위치에서 물고기를 먹을 수 있다면?
                    if(map[nx][ny] != 0 && map[nx][ny] < size) {
                        map[nx][ny] = 0;
                        eat++;
                        move += (cur.dis + 1);
                        isEat = true;
                        cur = new Point(nx, ny, 0);
                        break; // 여기서 break을 걸어버리면? 
                        // for문으로 돌아가게 됨. 맨 위의 while로 돌아가야 하는데 의도대로 안됨.
                        
                    }

                    // 이동
                    pQ.offer(new Point(nx, ny, cur.dis + 1));
                    visited[nx][ny] = true;
                }
            }
```



---

시뮬레이션, BFS

```java
import java.util.*;
import java.io.*;

class Main {

    static class Point implements Comparable<Point> {
        int x, y, dis;

        Point(int x, int y, int dis) {
            this.x = x;
            this.y = y;
            this.dis = dis;
        }

        @Override
        public int compareTo(Point ob) {
            if(this.dis == ob.dis) { // 거리가 같다면
                if(this.x == ob.x) return this.y - ob.y; // 둘 다 가장 위에 있다면, 왼쪽에 있는게 우선
                return this.x - ob.x; // 가장 위에 있는게 우선
            }
            // 거리가 다르다면
            return this.dis - ob.dis; // 가장 가까운 거리가 우선순위
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;

    static int[][] map;
    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    static int n;
    public static void main(String[] args) throws IOException {
        
        n = Integer.parseInt(br.readLine());
        map = new int[n][n];

        Point cur = null;

        for(int i=0; i<n; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<n; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
                if(map[i][j] == 9) {
                    cur = new Point(i, j, 0);
                    map[i][j] = 0;
                }
            }
        }

        System.out.println(BFS(cur));

    }

    static int BFS(Point start) {
        
        int size = 2; // 상어 크기
        int eat = 0; // 물고기 먹은 획수
        int move = 0; // 이동 횟수

        Point cur = start; // 상어 시작 위치. 매번 초기화

        while(true) {
            PriorityQueue<Point> pQ = new PriorityQueue<>();
            boolean[][] visited = new boolean[n][n];
            boolean isEat = false; // 물고기를 먹었는지 여부
            pQ.offer(new Point(cur.x, cur.y, 0));
            visited[cur.x][cur.y] = true;

            // 물고기 탐색 시작
            while(!pQ.isEmpty()) {
                cur = pQ.poll(); // 상어의 현재 위치

                // 현재 위치에서 물고기를 먹을 수 있다면?
                if(map[cur.x][cur.y] != 0 && map[cur.x][cur.y] < size) {
                    map[cur.x][cur.y] = 0;
                    eat++;
                    move += cur.dis;
                    isEat = true;
                    break;
                }

                // 현재 위치에서 사방면 탐색
                for(int d=0; d<4; d++) {
                    int nx = cur.x + dx[d];
                    int ny = cur.y + dy[d];

                    // 범위X or 이미 방문 or 자신보다 큰 물고기라면 PASS
                    if(!rangeCheck(nx, ny) || visited[nx][ny] || map[nx][ny] > size) continue;

                    // 이동
                    pQ.offer(new Point(nx, ny, cur.dis + 1));
                    visited[nx][ny] = true;
                }
            }

            // 탐색 동안에 물고기를 못먹었다면, 엄마 상어 호출
            if(!isEat) return move;

            // 물고기의 크기를 증가시킬 수 있다면
            if(size == eat) {
                size++;
                eat = 0;
            }
        }   

    }

    static boolean rangeCheck(int nx, int ny) {
        return nx >= 0 && ny >= 0 && nx < n && ny < n;
    }

}


```