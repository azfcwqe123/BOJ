<img width="940" height="940" alt="image" src="https://github.com/user-attachments/assets/38173823-0b98-4fa2-89eb-4d70c55a9011" />

<img width="964" height="732" alt="image" src="https://github.com/user-attachments/assets/c389f17b-8ee4-4bf7-8cfd-dd32b67b5a7a" />

문제: https://www.acmicpc.net/problem/14891

참고 블로그: https://loosie.tistory.com/546

---

### Hint

1. 내 첫 풀이는 현재 돌아가는 톱니바퀴에 의해 영향받는 다른 톱니바퀴들을 boolean[] 배열로 체크해둔뒤, 마지막에 모두 한 번에 돌리는 방법을 썼지만 이렇게 하면 코드가 매우 장황해짐. 정답으로 뜨긴 했지만 매우 비효율적이라고 판단.
   - boolean[] 배열에 체크돼있는 배열들을 참고해서 회전하려할때, 회전을 해야한다는 체크만 했지, 현재 톱니바퀴 위치에서 dir 방향으로 어떻게 인접한 톱니바퀴들을 회전시킬지 생각을 안 했음. 막상 회전해야할 톱니바퀴들을 구하고 난뒤에도 순수 구현을 할 수밖에 없었음.

&nbsp; 

2. 재귀로 왼쪽, 오른쪽을 탐색하면서 맞닿은 극이 생길 경우 실시간으로 회전시켜주면서 하는것이 정답.

---

처음에 순수 구현으로 풀었는데, 코드가 너무 장황해지고 뭔가 이상하다 싶어서 다른 블로그를 참고함. 재귀로 인접해있는 톱니바퀴를 돌릴 수 있는지 판단하는게 정말 유용한 풀이었음.

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static int[][] data = new int[4][8];
    public static void main(String[] args) throws IOException {
        
        for(int i=0; i<4; i++) {
            String str = br.readLine();
            for(int j=0; j<8; j++) {
                data[i][j] = str.charAt(j) - '0';
            }
        }

        int k = Integer.parseInt(br.readLine());

        while(k-- > 0) {
            st = new StringTokenizer(br.readLine());
            int num = Integer.parseInt(st.nextToken()) - 1;
            int dir = Integer.parseInt(st.nextToken());

            // 작동 시작
            gearOperation(num , dir);
        }

        int sum = 0;
        for(int i=0; i<4; i++) {
            sum += Math.pow(2, i) * data[i][0];
        }
        System.out.println(sum);

    }    

    static void gearOperation(int num, int dir) {

        left(num - 1, -dir); // 왼쪽 탐색
        right(num + 1, -dir); // 오른쪽 탐색
        rotate(num, dir); // 현재 톱니바퀴 회전
    }

    static void left(int num, int dir) {
        if(num < 0) return; // 범위에 벗어나면 X
        if(data[num][2] == data[num+1][6]) return; // 맞닿은 극이 같으면 X
        left(num - 1, -dir); // 왼쪽 이어서 탐색
        rotate(num, dir); // 현재 톱니바퀴 회전(맞닿은 극이 같지 않음을 만족함)
    }

    static void right(int num, int dir) {
        if(num > 3) return; // 범위에 벗어나면 X
        if(data[num][6] == data[num-1][2]) return; // 맞닿은 극이 같으면 X
        right(num + 1, -dir); // 오른쪽 이어서 탐색
        rotate(num, dir); // 현재 톱니바퀴 회전(맞닿은 극이 같지 않음을 만족함)
    }

    static void rotate(int num, int dir) {
        if(dir == 1)  { // 시계방향 회전
            int tmp = data[num][7];
            for(int i=7; i>0; i--) data[num][i] = data[num][i-1];
            data[num][0] = tmp;
        }

        else { // 반시계방향 회전
            int tmp = data[num][0];
            for(int i=0; i<7; i++) data[num][i] = data[num][i+1];
            data[num][7] = tmp;
        }
    }

}


```

---

순수 구현

```java
import java.util.*;
import java.io.*;

class Main {

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();

    static int[] A = new int[8];
    static int[] B = new int[8];
    static int[] C = new int[8];
    static int[] D = new int[8];

    static int k, num, dir;
    public static void main(String[] args) throws IOException {
        
        init();    
        
        k = Integer.parseInt(br.readLine());

        while(k-- > 0) {
            st = new StringTokenizer(br.readLine());

            int num = Integer.parseInt(st.nextToken());
            int dir = Integer.parseInt(st.nextToken());

            rotate(num, dir);
        }

        int a = (A[0] == 0 ? 0 : 1);
        int b = (B[0] == 0 ? 0 : 2);
        int c = (C[0] == 0 ? 0 : 4);
        int d = (D[0] == 0 ? 0 : 8);

        System.out.println(a + b + c + d);

    }    

    // 6 ---- 2
    static void rotate(int num, int dir) {
        
        boolean[] check = new boolean[5];

        if(num == 1) {
            check[1] = true;
            if(A[2] != B[6]) {
                    check[2] = true;
                if(B[2] != C[6]) {
                    check[3] = true;
                    if(C[2] != D[6]) {
                        check[4] = true;
                    }
                }
            }

            if(dir == 1) { // 시계방향일경우
                if(check[1]) cw(A);
                if(check[2]) ccw(B);
                if(check[3]) cw(C);
                if(check[4]) ccw(D);
            }

            else { // 반시계 방향일경우
                if(check[1]) ccw(A);
                if(check[2]) cw(B);
                if(check[3]) ccw(C);
                if(check[4]) cw(D);
            }
        }

        else if(num ==2) {
            check[2] = true;
            if(B[6] != A[2]) check[1] = true;

            if(B[2] != C[6]) {
                check[3] = true;
                if(C[2] != D[6]) check[4] = true;
            }

            if(dir == 1) { // 시계방향일경우
                if(check[1]) ccw(A);
                if(check[2]) cw(B);
                if(check[3]) ccw(C);
                if(check[4]) cw(D);
            }

            else { // 반시계 방향일경우
                if(check[1]) cw(A);
                if(check[2]) ccw(B);
                if(check[3]) cw(C);
                if(check[4]) ccw(D);
            }
        }

        else if(num == 3) {
            check[3] = true;
            if(C[2] != D[6]) check[4] = true;

            if(C[6] != B[2]) {
                check[2] = true;
                if(B[6] != A[2]) check[1] = true;
            }

            if(dir == 1) { // 시계방향일경우
                if(check[1]) cw(A);
                if(check[2]) ccw(B);
                if(check[3]) cw(C);
                if(check[4]) ccw(D);
            }

            else { // 반시계 방향일경우
                if(check[1]) ccw(A);
                if(check[2]) cw(B);
                if(check[3]) ccw(C);
                if(check[4]) cw(D);
            }
        }

        // 6 --- 2
        else if(num == 4) {
            check[4] = true;
            if(D[6] != C[2]) {
                check[3] = true;
                if(C[6] != B[2]) {
                    check[2] = true;
                    if(B[6] != A[2]) {
                        check[1] = true;
                    }
                }
            }

            if(dir == 1) { // 시계방향일경우
                if(check[1]) ccw(A);
                if(check[2]) cw(B);
                if(check[3]) ccw(C);
                if(check[4]) cw(D);
            }

            else { // 반시계 방향일경우
                if(check[1]) cw(A);
                if(check[2]) ccw(B);
                if(check[3]) cw(C);
                if(check[4]) ccw(D);
            }
        }
    }

    static void init() throws IOException {
        String str = br.readLine();

        for(int i=0; i<8; i++) A[i] = str.charAt(i) - '0';    

        str = br.readLine();
        for(int i=0; i<8; i++) B[i] = str.charAt(i) - '0';    

        str = br.readLine();
        for(int i=0; i<8; i++) C[i] = str.charAt(i) - '0';    

        str = br.readLine();
        for(int i=0; i<8; i++) D[i] = str.charAt(i) - '0';    
    }

    static void cw(int[] A) { // 시계 방향
        int tmp = A[7];

        for(int i=7; i>=1; i--) A[i] = A[i-1];

        A[0] = tmp;
    }

    static void ccw(int[] A) { // 반시계 방향
        int tmp = A[0];

        for(int i=1; i<=7; i++) A[i-1] = A[i];
        
        A[7] = tmp;
    }

}


```