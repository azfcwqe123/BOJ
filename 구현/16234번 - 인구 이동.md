<img width="1076" height="808" alt="image" src="https://github.com/user-attachments/assets/c5dfd1e0-b0b1-4ea0-98be-862372f8bae2" />

문제: https://www.acmicpc.net/problem/16234

---

### Hint

1.  위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.
- BFS 탐색을 유도한다.
&nbsp;

2. 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.
- 국경선을 먼저 모두 개방하고 탐색을 시작할건지, 실시간으로 국경선을 개방하면서 탐색할건지 정해야함.
&nbsp;

3. 각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성하시오
- while(true)을 사용해서, 문제 종료 조건에 부합할시 탐색 종료



---
BFS

```java
import java.util.*;
import java.io.*;

class Main {

    static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y =y;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static int N, L, R;
    static int[][] map;
    static boolean[][] visited;
    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    static Stack<Point> stack; // 인구 이동 필요한 국가들
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        L = Integer.parseInt(st.nextToken());
        R = Integer.parseInt(st.nextToken());
        map = new int[N][N];
        
        for(int i=0; i<N; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        System.out.println(solution());
    }    

    static int solution() {

        int time = 0;

        while(true) { // 며칠동안 발생했는지?
            visited = new boolean[N][N];
            boolean isMove = false; // 국경 개방 여부

            for(int i=0; i<N; i++) {
                for(int j=0; j<N; j++) {
                    if(!visited[i][j]) { // 아직 방문해보지 않은 국경이라면 탐색 시작
                        int sum = BFS(i, j);

                        if(stack.size() > 1) { // 인구 이동 필요한 국가가 2개 이상이라면
                            change(sum); // 인구 이동 시작
                            isMove = true;
                        }
                    }
                }
            }
            if(!isMove) return time; // 국경을 개방하지 못한 날이라면 탐색 종료

            time++;
        }
       
    }

    static int BFS(int x, int y) {
        Queue<Point> Q = new LinkedList<>();
        stack = new Stack<>();
        Q.offer(new Point(x, y));
        visited[x][y] = true;

        int sum = 0;

        while(!Q.isEmpty()) {
            Point cur = Q.poll();
            stack.push(cur);
            sum += map[cur.x][cur.y];

            for(int d=0; d<4; d++) {
                int nx = cur.x + dx[d];
                int ny = cur.y + dy[d];

                if(!rangeCheck(nx, ny) || visited[nx][ny]) continue;

                // 두 국경의 인구 차이
                int diff = Math.abs(map[nx][ny] - map[cur.x][cur.y]);

                // L 이상, R 이하 조건을 만족한다면 국경 개방
                if(diff >= L && diff <= R) {
                    visited[nx][ny] = true;
                    Q.offer(new Point(nx, ny));
                }
                
            }
        }

        return sum;
    }

    // 인구 이동
    static void change(int sum) {

        int avg = sum / stack.size();

        while(!stack.isEmpty()) {
            Point cur = stack.pop();
            map[cur.x][cur.y] = avg;
        }
    }

    static boolean rangeCheck(int nx, int ny) {
        return nx>=0 && ny>=0 && nx < N && ny < N;
    }
}


```

---

실패했다가 틀린 코드 (4%)
&nbsp;

틀린 이유:

국경을

|1|1|
|---|---|
|2|2|

이렇게 놔눴어도, border 배열에는

|true|true|
|---|---|
|true|true|

이와 같이 저장되기 때문에, BFS로 국경 탐색할때 모두 같은 영역으로 보고 탐색해버림. 1과 2는 다른 영역

&nbsp;

코드 흐름은,

1. 국경을 먼저 나누고 -> border 배열
2. BFS로 국경 탐색

하지만 정답 코드에서는 국경을 먼저 모두 나누지 않고 실시간으로 나누면서 탐색함.  즉, 국경을 먼저 나눌 필요는 없었음

```java
import java.util.*;
import java.io.*;

class Main {

    static class Point {
        int x, y;

        Point(int x, int y) {
            this.x = x;
            this.y =y;
        }
    }

    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    static int N, L, R, time = 0;
    static int[][] map;
    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    public static void main(String[] args) throws IOException {
        
        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        L = Integer.parseInt(st.nextToken());
        R = Integer.parseInt(st.nextToken());
        map = new int[N][N];
        
        for(int i=0; i<N; i++) {
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        solution();

        System.out.println(time);
    }    

    static void solution() {

        while(true) {
            Queue<Point> Q = new LinkedList<>();
            Stack<Point> stack = new Stack<>();

            boolean[][] border = new boolean[N][N];
            boolean[][] visited = new boolean[N][N];

            openBorder(border); // 국경 개방

            for(int i=0; i<N; i++) {
                for(int j=0; j<N; j++) {
                    if(border[i][j]) { // 국경이 열려있는 곳만 이동
                        stack.push(new Point(i, j));
                        Q.offer(new Point(i, j));
                        visited[i][j] = true;
                        
                        int sum = 0, cnt = 0;

                        while(!Q.isEmpty()) { // 국경 탐색
                            Point cur = Q.poll();

                            sum += map[cur.x][cur.y];
                            cnt++;

                            for(int d=0; d<4; d++) {
                                int nx = cur.x + dx[d];
                                int ny = cur.y + dy[d];

                                if(!rangeCheck(nx, ny) || !border[nx][ny] || visited[nx][ny]) continue;

                                visited[nx][ny] = true;
                                Q.offer(new Point(nx, ny));
                                stack.push(new Point(nx, ny));
                            }
                        }

                        int area = sum / cnt;

                        while(!stack.isEmpty()) {
                            Point cur = stack.pop();                            
                            map[cur.x][cur.y] = area;
                        }
                    }
                }
            }

            boolean flag = false;

            for(int i=0; i<N; i++) {
                for(int j=0; j<N; j++) {
                    if(border[i][j] == true) {
                        flag = true;
                        break;
                    }
                }
            }

            // // 디버깅
            // System.out.println();
            // for(int i=0; i<N; i++) {
            //     for(int j=0; j<N; j++) {
            //         System.out.print(map[i][j] + " ");
            //     }
            //     System.out.println();
            // }
            // System.out.println();

            if(!flag) return;
            

            time++;
        }
    }


    static boolean[][] openBorder(boolean[][] border) { // 국경 개방

        for(int i=0; i<N; i++) {
            for(int j=0; j<N; j++) {
                
                for(int d=0; d<4; d++) {
                    int nx = i + dx[d];
                    int ny = j + dy[d];

                    if(!rangeCheck(nx, ny) || border[nx][ny] == true) continue;

                    if(Math.abs(map[nx][ny] - map[i][j]) >= L && Math.abs(map[nx][ny] - map[i][j]) <= R) {
                        border[i][j] = border[nx][ny] = true;
                    }
                }                
            }
        }
        return border;
    }

    static boolean rangeCheck(int nx, int ny) {
        return nx>=0 && ny>=0 && nx < N && ny < N;
    }
}


```